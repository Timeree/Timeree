!/usr/bin/env python3
import os, sys
from io import BytesIO
from tempfile import SpooledTemporaryFile
from pyftpdlib.authorizers import DummyAuthorizer
from pyftpdlib.handlers import FTPHandler
from pyftpdlib.servers import FTPServer
from pyftpdlib.filesystems import AbstractedFS
from cryptography.hazmat.primitives.ciphers.aead import AESGCM

==================== 配置 ====================
PORT = 35121
ROOT_DIR = os.path.expanduser("~/Timeree/private/blobs")
os.makedirs(ROOTDIR, existok=True)
USERNAME = "Timeree"
PASSIVE_PORTS = range(31110, 31112)

==================== 密钥检查 ====================
if len(sys.argv) < 2:
    print("用法: python3 server.py <16字节密钥>")
    sys.exit(1)

KEY = sys.argv[1]
if len(KEY.encode()) != 16:
    print("错误: 密钥必须是 16 字节 (16 个字符)")
    sys.exit(1)
KEYCODE = KEY.encode()

==================== 加密文件系统 ====================
class EncryptedFS(AbstractedFS):
    def open(self, filename, mode):
        path = self.getreal_path(filename)
        if 'b' not in mode: mode += 'b'

        if mode.startswith('r'):
            # 下载：解密文件
            if not os.path.exists(path):
                raise FileNotFoundError(filename)
            data = open(path, 'rb').read()
            if len(data) < 28:   # 空文件或太小文件 → 返回空内容
                return BytesIO(b"")
            iv, ct_tag = data[:12], data[12:]
            try:
                pt = AESGCM(KEYCODE).decrypt(iv, ct_tag, None)
            except Exception:
                pt = data  # 解密失败时返回原始内容
            return BytesIO(pt)

        elif mode.startswith('w'):
            # 上传：加密保存
            class EncryptingFile:
                def init(self, path):
                    self.temp = SpooledTemporaryFile(max_size=1010241024)
                    self.path = path
                def write(self, data): return self.temp.write(data)
                def close(self):
                    self.temp.seek(0)
                    plaintext = self.temp.read()
                    aesgcm = AESGCM(KEYCODE)
                    iv = os.urandom(12)
                    ciphertext = aesgcm.encrypt(iv, plaintext, None)
                    with open(self.path, 'wb') as f:
                        f.write(iv + ciphertext)
                    self.temp.close()
                def getattr(self, name): return getattr(self.temp, name)
            return EncryptingFile(path)

        else:
            raise ValueError("不支持的模式")

    # 基础文件操作
    def listdir(self, path): return os.listdir(self.getreal_path(path))
    def mkdir(self, path): os.mkdir(self.getreal_path(path))
    def rmdir(self, path): os.rmdir(self.getreal_path(path))
    def remove(self, path): os.remove(self.getreal_path(path))
    def exists(self, path): return os.path.exists(self.getreal_path(path))
    def isfile(self, path): return os.path.isfile(self.getreal_path(path))
    def isdir(self, path): return os.path.isdir(self.getreal_path(path))
    def getsize(self, path):
        realpath = self.getrealpath(path)
        if not os.path.exists(real_path): return 0
        try:
            data = open(real_path, 'rb').read()
            if len(data) < 28: return 0
            iv, ct_tag = data[:12], data[12:]
            pt = AESGCM(KEYCODE).decrypt(iv, ct_tag, None)
            return len(pt)
        except:
            return os.path.getsize(real_path)
    def getreal_path(self, path):
        if os.path.isabs(path): return path
        return os.path.abspath(os.path.join(self.root, path.lstrip('/')))

==================== 主程序 ====================
def main():
    authorizer = DummyAuthorizer()
    authorizer.adduser(USERNAME, KEY, ROOTDIR, perm="elradfmwM")

    handler = FTPHandler
    handler.authorizer = authorizer
    handler.abstracted_fs = EncryptedFS
    handler.banner = "Timeree Encrypted FTP Ready"
    handler.passiveports = PASSIVEPORTS

    server = FTPServer(("0.0.0.0", PORT), handler)

    print("=== 加密 FTP 服务器启动 ===")
    print(f"端口: {PORT}")
    print(f"根目录: {ROOT_DIR}")
    print(f"用户名: {USERNAME}")
    print(f"密钥: {KEY}")
    print("按 Ctrl+C 停止服务器\n")

    try:
        server.serve_forever()
    except KeyboardInterrupt:
        print("\n服务器已停止")

if name == "main":
    main()

